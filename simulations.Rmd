---
title: "Simulations"
author: "Benjamin Hoffner-Brodsky"
date: "4/28/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

remove(list = ls())
options(mc.cores = parallel::detectCores())

# Definitions

# There are two states, A and B 
# Exactly one is true/right 

# Agents receive a discrete signal
# a correlates with state A
# b correlates with state B 
# o correlates symmetrically with A and B

# pi is the prior that state = A

```

```{r functions}

# Generate Starting Matrices

init_matrix <- function(iterations, herd_length){
  
  temp_matrix <- matrix(0, iterations, herd_length)
  return(temp_matrix)
  
}

# Assign i.i.d signals to signal_matrix 

# eta is the symmetric probability of generating null 
# P(signal = o | state = A) = P(signal = o | state = B) = eta

# alpha is the power of signal a to predict state A
# P(signal = a | state = A) = alpha * eta 

# beta is the power of signal b to predict state B 
# P(signal = b | state = B) = beta * eta

# Loop over state 

gen_signals <- function(signal_matrix, eta, alpha, beta, state){
  signals <- sample(c("a", "b", "o"), size = length(signal_matrix), replace = TRUE, 
# P(signal = b | state = A) = 1 - P(signal = 0 | state = A) - P(signal = a | state = A)
                    prob = c(ifelse(state == "a", alpha * eta, 1 - eta - beta * eta),
# P(signal = a | state = B) = 1 - P(signal = o | state = B) - P(signal = b | state = B)
                             ifelse(state == "b", beta * eta, 1 - eta - alpha * eta),
                             eta))
  return(matrix(signals, nrow(signal_matrix), ncol(signal_matrix)))
}

# Input a decision history and output a posterior

infer_on_signal <- function(signal_matrix, decision_matrix, prior, generation){
    
# Only run once in the loop
  
  if (generation > 1) {
    
# Need to temporarily concatenate observed decisions in order to match with
# action posterior matrix
    
    decision_matrix <- matrix(apply(format(decision_matrix), 1, paste, collapse = ""), iterations, 1)
    prior <- as.numeric(prior[c(match(decision_matrix, prior)), 4])
  }
  
    posterior_with_signal_a <- alpha * eta * prior / (alpha * eta * prior + (1 - eta - beta * eta) * (1 - prior))
    posterior_with_signal_b <- (1 - eta - alpha * eta) * prior / (((1 - eta - alpha * eta) * prior) + beta * eta * (1 - prior))
    posterior_with_signal_null <- prior
    posterior <- ifelse(signal_matrix[, generation] == "a", posterior_with_signal_a,
                        ifelse(signal_matrix[, generation] == "b", posterior_with_signal_b,
                               posterior_with_signal_null))
    return(posterior)
    
}

# Create action posterior matrix

infer_on_actions <- function(decision_summary_df_a, decision_summary_df_b, prior, generation){
  temp_matrix <- matrix(0, nrow(decision_summary_df_a), 3)
  temp_matrix[, 1] <- decision_summary_df_a[, 2]
  temp_matrix[, 2] <- decision_summary_df_b[, 2]
  temp_matrix[, 3] <- (prior * temp_matrix[, 1]) / (prior * temp_matrix[, 1] + (1 - prior) * temp_matrix[, 2])
  temp_matrix <- cbind(levels(decision_summary_df_a[, 1]), temp_matrix)
  return(temp_matrix)
}

# Input a posterior and output a decision

decide <- function(posterior_matrix, signal_matrix, generation){
  decisions <- ifelse(posterior_matrix[, generation] > 0.5, "A", 
                                ifelse(posterior_matrix[, generation] < 0.5, "B",
                                       ifelse(signal_matrix[, generation] == "a", "A",
                                              ifelse(signal_matrix[, generation] == "b", "B",
                                                     sample(c("A", "B"), 
                                                            replace = TRUE, 
                                                            prob = c(0.5, 0.5))))))
  return(decisions)
}


```

```{r prep_for_loop}

# Set parameters

matrix_types <- c("posterior")
iterations <- 1000000
herd_length <- 20
eta <- 0.3
alpha <- 0.6
beta <- 0.7
pi <- 0.4
states <- c("a", "b") 

# Generates vectors of names of matrices for loops

for (matrix_type in matrix_types){
  assign(paste(matrix_type, "matrices", sep = "_"), paste(matrix_type, "matrix", states, sep = "_"))
}

# Initialize empty matrices

for (state in states){
  for (matrix_type in matrix_types){
    assign(paste(matrix_type, "matrix", state, sep = "_"), init_matrix(iterations, herd_length + 1))
  }
}

signal_matrix_a <- init_matrix(iterations, herd_length + 1)
signal_matrix_b <- init_matrix(iterations, herd_length + 1)

decision_matrix_a <- init_matrix(iterations, 1)
decision_matrix_b <- init_matrix(iterations, 1)

# Assign signals 

for (state in states){
  assign(paste("signal_matrix", state, sep = "_"), gen_signals(signal_matrix_a, eta, alpha, beta, state))
}

# Initialize list of decision summary data frames

decision_summary_a_dfs <- list()
decision_summary_b_dfs <- list()

for (generation in 1:herd_length) {
  
  decision_summary_a_dfs[[paste("decision_summary_a_df", generation, sep = "_")]] <- data.frame(NULL)
  decision_summary_b_dfs[[paste("decision_summary_b_df", generation, sep = "_")]] <- data.frame(NULL)
  
}

# Initialize a list of action posterior matrices

action_posterior_matrices <- list()

for (generation in 1:herd_length) {
  
  action_posterior_matrices[[paste("action_posterior_matrix", generation, sep = "_")]] <- data.frame(NULL)
  
}

```

```{r loop}

# For the special case in which there are no prior actions to consider
# Generating posterior for generation 1 solely after observing their own signal

posterior_matrix_a[, 1] <- infer_on_signal(signal_matrix_a, decision_matrix_a, pi, 1)
posterior_matrix_b[, 1] <- infer_on_signal(signal_matrix_b, decision_matrix_b, pi, 1)

for (generation in 1:herd_length) {
  
# Status report
  print(paste0("Simulating generation #", generation))
  
# Decide
  
  temp_decision_a <- decide(posterior_matrix_a, signal_matrix_a, generation)
  temp_decision_b <- decide(posterior_matrix_b, signal_matrix_b, generation)
  
  if (generation == 1) {
    decision_matrix_a <- as.matrix(temp_decision_a)
    decision_matrix_b <- as.matrix(temp_decision_b)
  }
  
  else {
    decision_matrix_a <- cbind(decision_matrix_a, temp_decision_a)
    decision_matrix_b <- cbind(decision_matrix_b, temp_decision_b)
  }
  

  # decision_matrix_a[, generation] <- decide(posterior_matrix_a, signal_matrix_a, generation)
  # decision_matrix_b[, generation] <- decide(posterior_matrix_b, signal_matrix_b, generation)
  
# Starting with generation 2, concatenate decisions into permutation string
  
  if (generation > 1) {
    cat_decision_matrix_a <- matrix(apply(format(decision_matrix_a), 1, paste, collapse = ""), iterations, 1)
    cat_decision_matrix_b <- matrix(apply(format(decision_matrix_b), 1, paste, collapse = ""), iterations, 1)
    
# Generate decision summary data frames
    
    decision_summary_a_dfs[[paste("decision_summary_a_df", generation, sep = "_")]] <- 
    as.data.frame(table(cat_decision_matrix_a))
  
    decision_summary_b_dfs[[paste("decision_summary_b_df", generation, sep = "_")]] <- 
    as.data.frame(table(cat_decision_matrix_b))
    
  }
  
# Generate decision summary data frames
  
  else {
    decision_summary_a_dfs[[paste("decision_summary_a_df", generation, sep = "_")]] <- 
    as.data.frame(table(decision_matrix_a[, generation]))
  
    decision_summary_b_dfs[[paste("decision_summary_b_df", generation, sep = "_")]] <- 
    as.data.frame(table(decision_matrix_b[, generation]))
  }
  
# Infer posteriors from decision summary tables without signal

  action_posterior_matrices[[paste("action_posterior_matrix", generation, sep = "_")]] <- 
    infer_on_actions(decision_summary_a_dfs[[paste("decision_summary_a_df", generation, sep = "_")]], 
                     decision_summary_b_dfs[[paste("decision_summary_b_df", generation, sep = "_")]],
                     pi, generation)
  
# Generate posteriors from action posterior matrix with signal
  
  posterior_matrix_a[, generation + 1] <- infer_on_signal(signal_matrix_a, decision_matrix_a, 
                                             action_posterior_matrices[[paste("action_posterior_matrix", 
                                                                              generation, sep = "_")]],
                                             generation + 1)
  
  posterior_matrix_b[, generation + 1] <- infer_on_signal(signal_matrix_b, decision_matrix_b, 
                                             action_posterior_matrices[[paste("action_posterior_matrix", 
                                                                              generation, sep = "_")]],
                                             generation + 1)
  


}

```

```{r display}

print(action_posterior_matrices)
```



