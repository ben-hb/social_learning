---
title: "Simulations"
author: "Benjamin Hoffner-Brodsky"
date: "4/28/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# Definitions

# There are two states, A and B 
# Exactly one is true/right 

# Agents receive a discrete signal
# a correlates with state A
# b correlates with state B 
# o correlates symmetrically with A and B

# pi is the prior that state = A

```

```{r functions}

# Generate Starting Matrices

init_matrix <- function(iterations, herd_length){
  
  temp_matrix <- matrix(0, iterations, herd_length)
  return(temp_matrix)
  
}

# Assign i.i.d signals to signal_matrix 

# eta is the symmetric probability of generating null 
# P(signal = o | state = A) = P(signal = o | state = B) = eta

# alpha is the power of signal a to predict state A
# P(signal = a | state = A) = alpha * eta 

# beta is the power of signal b to predict state B 
# P(signal = b | state = B) = beta * eta

# Loop over state 

gen_signals <- function(signal_matrix, eta, alpha, beta, state){
  signals <- sample(c("a", "b", "o"), size = length(signal_matrix), replace = TRUE, 
# P(signal = b | state = A) = 1 - P(signal = 0 | state = A) - P(signal = a | state = A)
                    prob = c(ifelse(state == "A", alpha * eta, 1 - eta - beta * eta),
# P(signal = a | state = B) = 1 - P(signal = o | state = B) - P(signal = b | state = B)
                             ifelse(state == "B", beta * eta, 1 - eta - alpha * eta),
                             eta))
  return(matrix(signals, nrow(signal_matrix), ncol(signal_matrix)))
}

# Input a decision history and output a posterior

infer <- function(signal_matrix, decision_matrix){
  return(ifelse(signal_matrix[, 1] == "a", alpha * eta, 
                                  ifelse(signal_matrix[, 1] == "b", 1 - eta - alpha * eta, eta)) * pi / 
    ((ifelse(signal_matrix[, 1] == "a", alpha * eta, 
                ifelse(signal_matrix[, 1] == "b", 1 - eta - alpha * eta, eta)) * pi) + 
          ifelse(signal_matrix[, 1] == "a", 1 - eta - beta * eta, 
                 ifelse(signal_matrix[, 1] == "b", beta * eta, eta)) * (1 - pi)))

}

# Input a posterior and output a decision

decide <- function(posterior_matrix, decision_matrix){
  
}


```


```{r simulate}

# Initialize matrices

iterations = 1000
herd_length = 15
eta = 0.5
alpha = 0.7
beta = 0.6
pi = 0.5

for (state in c("a", "b")){
  for (matrix_type in c("signal", "posterior", "decision")){
  assign(paste(matrix_type, "matrix", state, sep = "_"), init_matrix(iterations, herd_length))
  }
}

# Assign signals 

for (state in c("a", "b")){
  assign(paste("signal_matrix", state, sep = "_"), gen_signals(signal_matrix_a, eta, alpha, beta, state))
}

# Infer column 1 

posterior_matrix_a[,1] <- infer(signal_matrix_a, decision_matrix_a)
posterior_matrix_b[,1] <- infer(signal_matrix_b, decision_matrix_b)

```



```{r test}

prepare(iterations = 10, herd_length = 5)

```

