---
title: "Simulations"
author: "Benjamin Hoffner-Brodsky"
date: "4/28/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# Definitions

# There are two states, A and B 
# Exactly one is true/right 

# Agents receive a discrete signal
# a correlates with state A
# b correlates with state B 
# o correlates symmetrically with A and B

```

```{r functions}

# Generate Starting Matrices

init_matrix <- function(iterations, herd_length){
  
  temp_matrix <- matrix(0, iterations, herd_length)
  return(temp_matrix)
  
}

for (state in c("a", "b")){
  for (matrix_type in c("signal", "posterior", "decision")){
  assign(paste(matrix_type, "matrix", state, sep = "_"), init_matrix(iterations, herd_length))
  }
}

  
  
  # Data structures for simulations where state = i
  signal_matrix_a <- matrix(0, iterations, herd_length)
  posterior_matrix_a <- matrix(0, iterations, herd_length)
  decision_matrix_a <- matrix(0, iterations, herd_length)
  
  # Data structures for simulations where state = B
  signal_matrix_b <- matrix(0, iterations, herd_length)
  posterior_matrix_b <- matrix(0, iterations, herd_length)
  decision_matrix_b <- matrix(0, iterations, herd_length)


# Assign i.i.d signals to signal_matrix 

# eta is the symmetric probability of generating null 
# P(signal = o | state = A) = P(signal = o | state = B) = eta

# alpha is the power of signal a to predict state A
# P(signal = a | state = A) = alpha * eta 

# beta is the power of signal b to predict state B 
# P(signal = b | state = B) = beta * eta

# Loop over state 

gen_signals <- function(signal_matrix, eta, alpha, beta, state){
  signals <- sample(c("a", "b", "o"), size = length(signal_matrix), replace = TRUE, 
# P(signal = b | state = A) = 1 - P(signal = 0 | state = A) - P(signal = a | state = A)
                    prob = c(ifelse(state == "A", alpha * eta, 1 - eta - beta * eta),
# P(signal = a | state = B) = 1 - P(signal = o | state = B) - P(signal = b | state = B)
                             ifelse(state == "B", beta * eta, 1 - eta - alpha * eta),
                             eta))
  signal_matrix <- matrix(signals, nrow(signal_matrix), ncol(signal_matrix))
}


infer <- function(posterior_matrix, decision_matrix){
  
}


# Input a posterior and output a decision

decide <- function(posterior_matrix, decision_matrix){
  
}


```

```{r test}

prepare(iterations = 10, herd_length = 5)

```

