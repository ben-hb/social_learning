---
title: "Simulations"
author: "Benjamin Hoffner-Brodsky"
date: "4/28/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

remove(list = ls())
options(mc.cores = parallel::detectCores())

# Definitions

# There are two states, A and B 
# Exactly one is true/right 

# Agents receive a discrete signal
# a correlates with state A
# b correlates with state B 
# o correlates symmetrically with A and B

# pi is the prior that state = A

```

```{r functions}

# Generate Starting Matrices

init_matrix <- function(iterations, herd_length){
  
  temp_matrix <- matrix(0, iterations, herd_length)
  return(temp_matrix)
  
}

# Assign i.i.d signals to signal_matrix 

# eta is the symmetric probability of generating null 
# P(signal = o | state = A) = P(signal = o | state = B) = eta

# alpha is the power of signal a to predict state A
# P(signal = a | state = A) = alpha * eta 

# beta is the power of signal b to predict state B 
# P(signal = b | state = B) = beta * eta

# Loop over state 

gen_signals <- function(signal_matrix, eta, alpha, beta, state){
  signals <- sample(c("a", "b", "o"), size = length(signal_matrix), replace = TRUE, 
# P(signal = b | state = A) = 1 - P(signal = 0 | state = A) - P(signal = a | state = A)
                    prob = c(ifelse(state == "A", alpha * eta, 1 - eta - beta * eta),
# P(signal = a | state = B) = 1 - P(signal = o | state = B) - P(signal = b | state = B)
                             ifelse(state == "B", beta * eta, 1 - eta - alpha * eta),
                             eta))
  return(matrix(signals, nrow(signal_matrix), ncol(signal_matrix)))
}

# Input a decision history and output a posterior

infer_on_signal <- function(signal_matrix, decision_matrix, generation){
  return(ifelse(signal_matrix[, generation] == "a", alpha * eta, 
                                  ifelse(signal_matrix[, generation] == "b", 1 - eta - alpha * eta, eta)) * pi / 
    ((ifelse(signal_matrix[, generation] == "a", alpha * eta, 
                ifelse(signal_matrix[, generation] == "b", 1 - eta - alpha * eta, eta)) * pi) + 
          ifelse(signal_matrix[, generation] == "a", 1 - eta - beta * eta, 
                 ifelse(signal_matrix[, generation] == "b", beta * eta, eta)) * (1 - pi)))

}

# Create action posterior matrix

infer_on_actions <- function(decision_summary_df_a, decision_summary_df_b, pi){
  temp_matrix <- matrix(0, nrow(decision_summary_df_a), 3)
  temp_matrix[, 1] <- decision_summary_df_a[, 2]
  temp_matrix[, 2] <- decision_summary_df_b[, 2]
  temp_matrix[, 3] <- (pi * temp_matrix[, 1]) / (pi * temp_matrix[, 1] + (1 - pi) * temp_matrix[, 2])
  temp_matrix <- cbind(levels(decision_summary_df_a[, 1]), temp_matrix)
  return(temp_matrix)
}

# Input a posterior and output a decision

decide <- function(posterior_matrix, signal_matrix){
  decisions <- ifelse(posterior_matrix[, 1] > 0.5, "A", 
                                ifelse(posterior_matrix[, 1] < 0.5, "B",
                                       ifelse(signal_matrix[, 1] == "a", "A",
                                              ifelse(signal_matrix[, 1] == "b", "B",
                                                     sample(c("A", "B"), 
                                                            replace = TRUE, 
                                                            prob = c(0.5, 0.5))))))
  return(decisions)
}


```

```{r prep_for_loop}

# Set parameters

matrix_types <- c("signal", "posterior", "decision")
iterations <- 100000
herd_length <- 2
eta <- 0.5
alpha <- 0.7
beta <- 0.6
pi <- 0.5
states <- c("a", "b") 

# Generates vectors of names of matrices for loops

for (matrix_type in matrix_types){
  assign(paste(matrix_type, "matrices", sep = "_"), paste(matrix_type, "matrix", states, sep = "_"))
}

# Initialize empty matrices

for (state in states){
  for (matrix_type in matrix_types){
    assign(paste(matrix_type, "matrix", state, sep = "_"), init_matrix(iterations, herd_length))
  }
}

# Assign signals 

for (state in states){
  assign(paste("signal_matrix", state, sep = "_"), gen_signals(signal_matrix_a, eta, alpha, beta, state))
}

```

```{r loop}

for (generation in 1:herd_length){
  
# Status report
  print(paste0("Simulating generation #", generation))
  
# Generate posterior with signal 

posterior_matrix_a[, generation] <- infer_on_signal(signal_matrix_a, decision_matrix_a, generation)
posterior_matrix_b[, generation] <- infer_on_signal(signal_matrix_b, decision_matrix_b, generation)
  
}

```

```{r simulate}





# Infer column 1 

posterior_matrix_a[, 1] <- infer_on_signal(signal_matrix_a, decision_matrix_a)
posterior_matrix_b[, 1] <- infer_on_signal(signal_matrix_b, decision_matrix_b)

# Decide column 1 

decision_matrix_a[, 1] <- decide(posterior_matrix_a, signal_matrix_a)
decision_matrix_b[, 1] <- decide(posterior_matrix_b, signal_matrix_b)

# Generate decision summary data frames for column 1

decision_summary_df_1_a <- as.data.frame(table(decision_matrix_a[, 1]))
decision_summary_df_1_b <- as.data.frame(table(decision_matrix_b[, 1]))

# Infer posteriors from decision summary tables 

action_posterior_matrix_1 <- infer_on_actions(decision_summary_df_1_a, decision_summary_df_1_b, pi)

# Generate posterior in column 2 of posterior_matrix 

posterior_without_signal_a <- as.numeric(action_posterior_matrix_1[c(match(decision_matrix_a[, 1], action_posterior_matrix_1)), 4])

posterior_with_signal_a_a <- alpha * eta * posterior_without_signal_a / 
  (alpha * eta * posterior_without_signal_a + (1 - eta - beta * eta) * (1 - posterior_without_signal_a))

posterior_with_signal_b_a <- (1 - eta - alpha * eta) * posterior_without_signal_a / 
  (((1 - eta - alpha * eta) * posterior_without_signal_a) + beta * eta * (1 - posterior_without_signal_a))

posterior_matrix_a[, 2] <- ifelse(signal_matrix_a[, 2] == "a", posterior_with_signal_a_a,
                                  ifelse(signal_matrix_a[, 2] == "b", posterior_with_signal_b_a,
                                  posterior_without_signal_a))

# b

posterior_without_signal_b <- as.numeric(action_posterior_matrix_1[c(match(decision_matrix_b[, 1], action_posterior_matrix_1)), 4])

posterior_with_signal_a_b <- alpha * eta * posterior_without_signal_b / 
  (alpha * eta * posterior_without_signal_b + (1 - eta - beta * eta) * (1 - posterior_without_signal_b))

posterior_with_signal_b_b <- (1 - eta - alpha * eta) * posterior_without_signal_b / 
  (((1 - eta - alpha * eta) * posterior_without_signal_b) + beta * eta * (1 - posterior_without_signal_b))

posterior_matrix_b[, 2] <- ifelse(signal_matrix_b[, 2] == "a", posterior_with_signal_a_b,
                                  ifelse(signal_matrix_b[, 2] == "b", posterior_with_signal_b_b,
                                  posterior_without_signal_b))

# Decide for column 2 


```





