---
title: "Simulations"
author: "Benjamin Hoffner-Brodsky"
date: "4/28/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

remove(list = ls())
options(mc.cores = parallel::detectCores())

# Definitions

# There are two states, A and B 
# Exactly one is true/right 

# Agents receive a discrete signal
# a correlates with state A
# b correlates with state B 
# o correlates symmetrically with A and B

# pi is the prior that state = A

```

```{r functions}

# Generate Starting Matrices

init_matrix <- function(iterations, herd_length) {
  
  temp_matrix <- matrix(0, iterations, herd_length)
  return(temp_matrix)
  
}

# Assign i.i.d signals to signal_matrix 

# eta is the symmetric probability of generating null 
# P(signal = o | state = A) = P(signal = o | state = B) = eta

# alpha is the power of signal a to predict state A
# P(signal = a | state = A) = alpha * eta 

# beta is the power of signal b to predict state B 
# P(signal = b | state = B) = beta * eta

# Loop over state 

gen_signals <- function(signal_matrix, eta, alpha, beta, state) {
  signals <- sample(c("a", "b", "o"), size = length(signal_matrix), replace = TRUE, 
# P(signal = b | state = A) = 1 - P(signal = 0 | state = A) - P(signal = a | state = A)
                    prob = c(ifelse(state == "a", alpha * (1 - eta), 1 - eta - beta * (1 - eta)),
# P(signal = a | state = B) = 1 - P(signal = o | state = B) - P(signal = b | state = B)
                             ifelse(state == "b", beta * (1 - eta), 1 - eta - alpha * (1 - eta)),
                             eta))
  return(matrix(signals, nrow(signal_matrix), ncol(signal_matrix)))
}

# Infer belief state = A before observing new signal 

infer_prior <- function(decision_matrix, prior, generation) {
  decision_matrix <- matrix(apply(format(decision_matrix), 1, paste, collapse = ""), iterations, 1)
  
  if (order == FALSE) {
    decision_matrix <- vapply(strsplit(decision_matrix, NULL), function(x) paste(sort(x), collapse = ''), '')
    decision_matrix <- matrix(decision_matrix)
  }
  
  prior <- as.numeric(prior[c(match(decision_matrix, prior)), 4])
  return(prior)
}

# Infer belief state = A if signal = a

infer_if_a <- function(prior) {
  
# Added a special exception for when prior is 0 or 1, such that if eta or alpha
# is 0 the inference function won't throw an error for dividing by 0
  
  posterior_with_signal_a <- ifelse(prior == 1, 1,
                                  ifelse(prior == 0, 0,
                                         alpha * (1 - eta) * prior / (alpha * (1 - eta) * prior + 
                                                                        (1 - eta - beta * (1 - eta)) * (1 - prior))))
  
  return(posterior_with_signal_a)
}

# Infer belief state = A if signal = b

# Added a special exception for when prior is 0 or 1, such that if eta or beta
# is 0 the inference function won't throw an error for dividing by 0

infer_if_b <- function(prior) {
  posterior_with_signal_b <- ifelse(prior == 1, 1,
                                    ifelse(prior == 0, 0,
                                    (1 - (1 - eta) - alpha * (1 - eta)) * prior / 
                                      (((1 - (1 - eta) - alpha * (1 - eta)) * prior) + beta * (1 - eta) * (1 - prior))))
    
  return(posterior_with_signal_b)
}

# Input a decision history and output a posterior

infer_on_signal <- function(signal_matrix, prior, posterior_with_signal_a, posterior_with_signal_b, generation) {
  posterior <- ifelse(signal_matrix[, generation] == "a", posterior_with_signal_a,
                        ifelse(signal_matrix[, generation] == "b", posterior_with_signal_b,
                               prior))
  return(posterior)
}

track_herd <- function(posterior_with_signal_a, posterior_with_signal_b, generation) {

# Check which iterations have herded

# If the last action was X and a signal of x would cause the next agent to take
# an action other than X, the iteration has herded

# Else, the iteration has not herded
    
  decisions_if_a <- decide(posterior_with_signal_a, c(rep("a", times = iterations)))
  decisions_if_b <- decide(posterior_with_signal_b, c(rep("b", times = iterations)))

  return(decisions_if_a == decisions_if_b)
  
}
    
# Create action posterior matrix

infer_on_actions <- function(decision_summary_df_a, decision_summary_df_b, prior, generation){
  temp_df <- dplyr::full_join(x = decision_summary_df_a, y = decision_summary_df_b, 
                       by = c("cat_decision_matrix_a" = "cat_decision_matrix_b"))
  temp_df[is.na(temp_df)] <- 0
  posterior <- (prior * temp_df$Freq.x) / (prior * temp_df$Freq.x + (1 - prior) * temp_df$Freq.y)
  temp_matrix <- as.matrix(cbind(temp_df, posterior))
  return(temp_matrix)
}

# Input a posterior and output a decision

decide <- function(posterior_column, signal_column){
  decisions <- ifelse(posterior_column > 0.5, "A", 
                                ifelse(posterior_column < 0.5, "B",
                                       ifelse(signal_column == "a", "A",
                                              ifelse(signal_column == "b", "B",
                                                     sample(c("A", "B"), 
                                                            replace = TRUE, 
                                                            prob = c(0.5, 0.5))))))
  return(decisions)
}

```


```{r loop}

# Set parameters

matrix_types <- c("posterior")
iterations <- 1000
herd_length <- 200
eta <- 0
alpha <- 0.8
beta <- 0.4
pi <- 0.1
states <- c("a", "b") 

# if FALSE, agents observe all actions before them 
# if an integer, each agent only observes the last n actions

memory_length <- FALSE

# Should order be considered?

order <- TRUE

# Parameter ranges

alpha_range <- c(seq(from = 0.01, to = 0.09, by = 0.01),
                 seq(from = 0.1, to = 0.9, by = 0.05),
                 seq(from = 0.91, to = 0.99, by = 0.01))
  
beta_range <- c(seq(from = 0.01, to = 0.09, by = 0.01),
                 seq(from = 0.1, to = 0.9, by = 0.05),
                 seq(from = 0.91, to = 0.99, by = 0.01))
  
# Check that parameter ranges satisfy conditions

# Condition 1: P(state = A | signal = a) >= P(state = A | signal = b)
# Condition 2: P(state = B | signal = b) >= P(state = B | signal = a)

# P(state = A | signal = a)

# paa <- alpha_range * pi / (alpha_range * pi + (1 - beta_range) * (1 - pi))
# 
# # P(state = A | signal = b)
# 
# pab <- (1 - alpha_range) * pi / (1 - alpha_range) * pi + beta_range * (1 - pi)
# 
# # Condition 1: P(state = A | signal = a) >= P(state = A | signal = b)
# 
# paa >= pab

temp_NAs <- rep(NA, times = length(alpha_range) * length(beta_range))

correct_herd_rate <- matrix(data = NA, nrow = length(beta_range), ncol = length(alpha_range))

correct_herd_rate_a <- data.frame(correct_herd_rate)
correct_herd_rate_b <- data.frame(correct_herd_rate)

row.names(correct_herd_rate_a) <- beta_range
row.names(correct_herd_rate_b) <- beta_range

colnames(correct_herd_rate_a) <- alpha_range
colnames(correct_herd_rate_b) <- alpha_range

for (beta in beta_range) {
  
for (alpha in alpha_range) {

# Generates vectors of names of matrices for loops

for (matrix_type in matrix_types){
  assign(paste(matrix_type, "matrices", sep = "_"), paste(matrix_type, "matrix", states, sep = "_"))
}

# Initialize empty matrices

for (state in states){
  for (matrix_type in matrix_types){
    assign(paste(matrix_type, "matrix", state, sep = "_"), init_matrix(iterations, herd_length + 1))
  }
}

signal_matrix_a <- init_matrix(iterations, herd_length + 1)
signal_matrix_b <- init_matrix(iterations, herd_length + 1)

decision_matrix_a <- init_matrix(iterations, 1)
decision_matrix_b <- init_matrix(iterations, 1)

# Assign signals 

for (state in states){
  assign(paste("signal_matrix", state, sep = "_"), gen_signals(signal_matrix_a, eta, alpha, beta, state))
}

# Initialize list of decision summary data frames

decision_summary_a_dfs <- list()
decision_summary_b_dfs <- list()

for (generation in 1:herd_length) {
  
  decision_summary_a_dfs[[paste("decision_summary_a_df", generation, sep = "_")]] <- data.frame(NULL)
  decision_summary_b_dfs[[paste("decision_summary_b_df", generation, sep = "_")]] <- data.frame(NULL)
  
}

# Initialize a list of action posterior matrices

action_posterior_matrices <- list()

for (generation in 1:herd_length) {
  
  action_posterior_matrices[[paste("action_posterior_matrix", generation, sep = "_")]] <- data.frame(NULL)
  
}

# Initialize a vector indicating which iterations have herded
# TRUE indicates that the generation has herded, FALSE indicates that it has not

herd_tracker_a_vectors <- list()
herd_tracker_b_vectors <- list()

for (generation in 1:herd_length) {
  herd_tracker_a_vectors[[paste("herd_tracker_a_vector", generation, sep = "_")]] <- c(rep(NA, times = iterations))
  herd_tracker_b_vectors[[paste("herd_tracker_b_vector", generation, sep = "_")]] <- c(rep(NA, times = iterations))
}

# Initialize a time tracking data frame 

# run_time_df <- data.frame(generation = character(), run_time = character())

# run_time_matrix <- matrix()

# For the special case in which there are no prior actions to consider
# Generating posterior for generation 1 solely after observing their own signal

# Calculate beliefs conditional on receiving signal a or b 
  
posterior_with_signal_a_a <- infer_if_a(pi)
posterior_with_signal_b_a <- infer_if_b(pi)

posterior_with_signal_a_b <- infer_if_a(pi)
posterior_with_signal_b_b <- infer_if_b(pi)

# Generate posteriors from action posterior matrix with signal
  
posterior_matrix_a[, 1] <- infer_on_signal(signal_matrix_a, pi, posterior_with_signal_a_a,
                                                          posterior_with_signal_b_a, 1)
  
posterior_matrix_b[, 1] <- infer_on_signal(signal_matrix_b, pi, posterior_with_signal_a_b,
                                                          posterior_with_signal_b_b, 1)

# Check which iterations have herded
  
herd_tracker_a_vectors[[1]] <- track_herd(posterior_with_signal_a_a, posterior_with_signal_b_a, 1)
herd_tracker_b_vectors[[1]] <- track_herd(posterior_with_signal_a_b, posterior_with_signal_b_b, 1)

# posterior_matrix_a[, 1] <- infer_on_signal(signal_matrix_a, decision_matrix_a, pi, generation = 1)
# posterior_matrix_b[, 1] <- infer_on_signal(signal_matrix_b, decision_matrix_b, pi, generation = 1)

start_time <- Sys.time()

for (generation in 1:herd_length) {
  
# Begin generation timer 
  
  # run_time_matrix[generation, 1] <- generation
  # run_time_matrix[generation, 2] <- Sys.time()
  
# Status report
  print(paste0("Simulating generation #", generation))

# Decide
  
  temp_decision_a <- decide(posterior_matrix_a[, generation], signal_matrix_a[, generation])
  temp_decision_b <- decide(posterior_matrix_b[, generation], signal_matrix_b[, generation])
  
  if (generation == 1) {
    decision_matrix_a <- as.matrix(temp_decision_a)
    decision_matrix_b <- as.matrix(temp_decision_b)
  }
  
  else {
    decision_matrix_a <- cbind(decision_matrix_a, temp_decision_a)
    decision_matrix_b <- cbind(decision_matrix_b, temp_decision_b)
  }
  
# Starting with generation 2, concatenate decisions into permutation string
  
  # if (generation > 1) {

    cat_decision_matrix_a <- matrix(apply(format(decision_matrix_a), 1, paste, collapse = ""), iterations, 1)
    cat_decision_matrix_b <- matrix(apply(format(decision_matrix_b), 1, paste, collapse = ""), iterations, 1)
  
  if (order == FALSE) {
    cat_decision_matrix_a <- vapply(strsplit(cat_decision_matrix_a, NULL), function(x) paste(sort(x), collapse = ''), '')
    cat_decision_matrix_b <- vapply(strsplit(cat_decision_matrix_b, NULL), function(x) paste(sort(x), collapse = ''), '')
    
    cat_decision_matrix_a <- matrix(cat_decision_matrix_a)
    cat_decision_matrix_b <- matrix(cat_decision_matrix_b)

  }
    
# Generate decision summary data frames
    
    decision_summary_a_dfs[[paste("decision_summary_a_df", generation, sep = "_")]] <- 
      as.data.frame(table(cat_decision_matrix_a))
    
    decision_summary_a_dfs[[paste("decision_summary_a_df", generation, sep = "_")]]$cat_decision_matrix_a <- 
      as.character(decision_summary_a_dfs[[paste("decision_summary_a_df", generation, sep = "_")]]$cat_decision_matrix_a)
  
    decision_summary_b_dfs[[paste("decision_summary_b_df", generation, sep = "_")]] <- 
      as.data.frame(table(cat_decision_matrix_b))
    
    decision_summary_b_dfs[[paste("decision_summary_b_df", generation, sep = "_")]]$cat_decision_matrix_b <- 
      as.character(decision_summary_b_dfs[[paste("decision_summary_b_df", generation, sep = "_")]]$cat_decision_matrix_b)
  
# Infer posteriors from decision summary tables without signal

  action_posterior_matrices[[paste("action_posterior_matrix", generation, sep = "_")]] <- 
    infer_on_actions(decision_summary_a_dfs[[paste("decision_summary_a_df", generation, sep = "_")]], 
                     decision_summary_b_dfs[[paste("decision_summary_b_df", generation, sep = "_")]],
                     pi, generation)

# Calculate belief that state = A before observing new signal 
  
  prior_a <- infer_prior(decision_matrix_a, action_posterior_matrices[[generation]], generation)
  prior_b <- infer_prior(decision_matrix_b, action_posterior_matrices[[generation]], generation)
  
# Calculate beliefs conditional on receiving signal a or b 
  
  posterior_with_signal_a_a <- infer_if_a(prior_a)
  posterior_with_signal_b_a <- infer_if_b(prior_a)
  
  posterior_with_signal_a_b <- infer_if_a(prior_b)
  posterior_with_signal_b_b <- infer_if_b(prior_b)
  
# Generate posteriors from action posterior matrix with signal
  
  posterior_matrix_a[, generation + 1] <- infer_on_signal(signal_matrix_a, prior_a, posterior_with_signal_a_a,
                                                          posterior_with_signal_b_a, generation + 1)
  
  posterior_matrix_b[, generation + 1] <- infer_on_signal(signal_matrix_b, prior_b, posterior_with_signal_a_b,
                                                          posterior_with_signal_b_b, generation + 1)
  
# Check which iterations have herded
  
  herd_tracker_a_vectors[[generation + 1]] <- track_herd(posterior_with_signal_a_a, posterior_with_signal_b_a, generation)
  herd_tracker_b_vectors[[generation + 1]] <- track_herd(posterior_with_signal_a_b, posterior_with_signal_b_b, generation)
  
# End generation timer and log 
  
  # end_time <- Sys.time()
  # time_elapsed <- as.character(end_time - start_time)
  # temp <- c(paste("Generation", as.character(generation), sep = " "), time_elapsed)
  # 
  # run_time_df <- rbind(run_time_df, temp)
  
  # run_time_matrix[generation, 3] <- Sys.time()
  
  if (sum(herd_tracker_a_vectors[[generation + 1]]) + sum(herd_tracker_b_vectors[[generation + 1]]) >= 2 * 99 * iterations / 100) {
    print(paste("All iterations have herded after ", generation, " generations. Ending simulation."))
    correct_herd_rate_a[as.character(beta), as.character(alpha)] <- sum(decision_matrix_a[, generation] == "A") / iterations
    correct_herd_rate_b[as.character(beta), as.character(alpha)] <- sum(decision_matrix_b[, generation] == "B") / iterations
    break
  }
}

}

}
# run_time_matrix[, 4] <- run_time_matrix[, 3] - run_time_matrix[, 2]

end_time <- Sys.time()
print(paste0("Run time for ", iterations, " iterations and a herd length of ", herd_length, ": ", round(end_time - start_time, 3), " seconds"))

```

```{r output}

library(xlsx)

write.xlsx(correct_herd_rate_a, "sample\ simulation/correct_herd_rate_unordered_0.1_a.xlsx")
write.xlsx(correct_herd_rate_b, "sample\ simulation/correct_herd_rate_unordered_0.1_b.xlsx")

# write.xlsx(action_posterior_matrices, "sample\ simulation/action_posterior_matrices.xlsx")
# write.xlsx(decision_matrix_a, "sample\ simulation/decision_matrix_a.xlsx")
# write.xlsx(decision_matrix_b, "sample\ simulation/decision_matrix_b.xlsx")
# write.xlsx(decision_summary_a_dfs, "sample\ simulation/decision_summary_a_dfs.xlsx")
# write.xlsx(decision_summary_b_dfs, "sample\ simulation/decision_summary_b_dfs.xlsx")
# write.xlsx(herd_tracker_a_vectors, "sample\ simulation/herd_tracker_a_vectors.xlsx")
# write.xlsx(herd_tracker_b_vectors, "sample\ simulation/herd_tracker_b_vectors.xlsx")
# write.xlsx(posterior_matrix_a, "sample\ simulation/posterior_matrix_a.xlsx")
# write.xlsx(posterior_matrix_b, "sample\ simulation/posterior_matrix_b.xlsx")
# write.xlsx(signal_matrix_a, "sample\ simulation/signal_matrix_a.xlsx")
# write.xlsx(signal_matrix_b, "sample\ simulation/signal_matrix_b.xlsx")


```



